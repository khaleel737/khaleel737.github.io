<!doctype html><html lang=en><head><script defer src=https://analytics.eu.umami.is/script.js data-website-id=ff740bb2-f741-4bc5-975e-49691d82ef39></script><meta charset=utf-8><meta name=generator content="Hugo 0.147.8"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content><meta property="og:url" content="https://maxhalford.github.io/blog/minimizing-sql-dag-runtime/"><link rel=canonical href=https://maxhalford.github.io/blog/minimizing-sql-dag-runtime/><meta property="og:url" content="https://maxhalford.github.io/blog/minimizing-sql-dag-runtime/"><meta property="og:site_name" content="Max Halford"><meta property="og:title" content="Minimizing the runtime of a SQL DAG"><meta property="og:description" content="I recently looked into reducing the runtime of Carbonfact‚Äôs SQL DAG. Our DAG is made up of roughly 160 SQL queries. It takes about 10 minutes to run with BigQuery, using on-demand pricing. It‚Äôs decent. However, the results of our DAG feed customer dashboards, and we have the (bad) habit of refreshing the DAG several times a day. Reducing the runtime by a few minutes can be a nice quality-of-life improvement."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-08T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-08T00:00:00+00:00"><meta property="article:tag" content="Data-Engineering"><meta property="article:tag" content="Python"><meta property="og:image" content="https://maxhalford.github.io/img/belle-ile.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://maxhalford.github.io/img/belle-ile.jpg"><meta name=twitter:title content="Minimizing the runtime of a SQL DAG"><meta name=twitter:description content="I recently looked into reducing the runtime of Carbonfact‚Äôs SQL DAG. Our DAG is made up of roughly 160 SQL queries. It takes about 10 minutes to run with BigQuery, using on-demand pricing. It‚Äôs decent. However, the results of our DAG feed customer dashboards, and we have the (bad) habit of refreshing the DAG several times a day. Reducing the runtime by a few minutes can be a nice quality-of-life improvement."><link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ü¶Ü</text></svg>"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/maxhalford.github.io\/"},"articleSection":"blog","name":"Minimizing the runtime of a SQL DAG","headline":"Minimizing the runtime of a SQL DAG","description":"\u003cp\u003eI recently looked into reducing the runtime of \u003ca href=\u0022https:\/\/www.carbonfact.com\/\u0022\u003eCarbonfact\u003c\/a\u003e\u0026rsquo;s SQL DAG. Our DAG is made up of roughly 160 SQL queries. It takes about 10 minutes to run with BigQuery, using on-demand pricing. It\u0026rsquo;s decent. However, the results of our DAG feed customer dashboards, and we have the (bad) habit of refreshing the DAG several times a day. Reducing the runtime by a few minutes can be a nice quality-of-life improvement.\u003c\/p\u003e","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"2025","datePublished":"2025-02-08 00:00:00 \u002b0000 UTC","dateModified":"2025-02-08 00:00:00 \u002b0000 UTC","url":"https:\/\/maxhalford.github.io\/blog\/minimizing-sql-dag-runtime\/","keywords":["data-engineering","python"]}</script><title>Minimizing the runtime of a SQL DAG ‚Ä¢ Max Halford</title><meta property="og:title" content="Minimizing the runtime of a SQL DAG ‚Ä¢ Max Halford"><meta property="og:type" content="article"><meta name=description content="I recently looked into reducing the runtime of Carbonfact&rsquo;s SQL DAG. Our DAG is made up of roughly 160 SQL queries. It takes about 10 minutes to run with BigQuery, using on-demand pricing. It&rsquo;s decent. However, the results of our DAG feed customer dashboards, and we have the (bad) habit of refreshing the DAG several times a day. Reducing the runtime by a few minutes can be a nice quality-of-life improvement."><link rel=stylesheet href=/css/flexboxgrid-6.3.1.min.css><link rel=stylesheet href=/css/github-markdown.min.css><link rel=stylesheet href=/css/highlight/github.css><link rel=stylesheet href=/css/index.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Permanent+Marker&display=swap" rel=stylesheet><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0,tags:"ams"},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><article class=post id=article><div class="row center-xs" style=text-align:left><div class="col-xs-12 col-sm-10 col-md-7 col-lg-5"><div class=header><header class=header-parts><div class="signatures site-title"><a href=/>Max Halford „ÉÑ</a></div><div class=header-links><a class=header-link href=/>Blog</a>
<a class=header-link href=/links/>Links</a>
<a class=header-link href=/bio/>Bio</a></div></header></div><header class=post-header><h1 class=post-title>Minimizing the runtime of a SQL DAG</h1><div class="row post-desc"><div class="col-xs-12 post-desc-items"><time class=posts-line-date datetime="2025-02-08 00:00:00 UTC">2025-02-08
</time><span class=posts-line-tag>data-engineering</span>
<span class=posts-line-tag>python</span></div></div></header><div class="post-content markdown-body"><p>I recently looked into reducing the runtime of <a href=https://www.carbonfact.com/>Carbonfact</a>&rsquo;s SQL DAG. Our DAG is made up of roughly 160 SQL queries. It takes about 10 minutes to run with BigQuery, using on-demand pricing. It&rsquo;s decent. However, the results of our DAG feed customer dashboards, and we have the (bad) habit of refreshing the DAG several times a day. Reducing the runtime by a few minutes can be a nice quality-of-life improvement.</p><p>There are essentially two options to reduce the runtime of a SQL DAG:</p><ol><li>Reduce the runtime of individual queries.</li><li>Remove dependencies between queries.</li></ol><p>The first option is rather straightforward. We process a lot of JSON data at Carbonfact, so I presume the queries involved need some optimization. I also have my eyes on the second option. Indeed, I suspect some key queries are bottlenecks; the runtime of the DAG could be reduced if these key queries were run earlier in the DAG.</p><p>The crux of the matter is to determine which queries to optimize, as well as which dependencies to remove. In a DAG, everything is running in parallel, so it&rsquo;s not exactly clear which queries are the bottleneck.</p><p>I was surprised to find little to no resources on this topic online. <a href=https://en.wikipedia.org/wiki/Transitive_reduction>Transitive reduction</a> is a well-known concept in graph theory, but it&rsquo;s not exactly what I&rsquo;m looking for. There&rsquo;s also the field of <a href=https://en.wikipedia.org/wiki/Queueing_theory>queueing theory</a>, but I haven&rsquo;t been able to find any practical resources on how to apply it to a DAG.</p><p>We&rsquo;re not using <a href=https://www.getdbt.com/>dbt</a> or <a href=https://sqlmesh.com/>SQLMesh</a> at Carbonfact. Instead we&rsquo;re using lea, which is a homegrown tool. But it&rsquo;s basically the same thing: a tool to execute a DAG of SQL queries asynchronously. lea produces logs, which messages like this:</p><pre tabindex=0><code>[15:27:07] SUCCESS
           int-data-kaya-prod.kaya_preview_main_39cdd31a.core.releases___audit,
           took 0:00:07, cost $0.00, contains 444 rows, weighs 171KB
</code></pre><p>I wrote a Python script to parse these logs and extract the duration of each query. I also got lea to spit out the DAG structure. I created aliases for each table, in order to not reveal our table names in this blog post. Here are both resulting files:</p><div><a href=/files/datasets/minimizing-sql-dag-runtime/dag_durations.txt><b>dag_durations.txt</b></a></div><div><a href=/files/datasets/minimizing-sql-dag-runtime/dag_dependencies.txt><b>dag_dependencies.txt</b></a></div><br><p>You should be able to use the code below if you are able to produce these two files with whatever system it is you&rsquo;re using.</p><p>First of all, here&rsquo;s some Python code to read the files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>collections</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pathlib</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>durations</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;: &#39;</span><span class=p>)[</span><span class=mi>0</span><span class=p>]:</span> <span class=nb>int</span><span class=p>(</span><span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;: &#39;</span><span class=p>)[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>pathlib</span><span class=o>.</span><span class=n>Path</span><span class=p>(</span><span class=s1>&#39;dag_durations.txt&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>read_text</span><span class=p>()</span><span class=o>.</span><span class=n>splitlines</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>dependencies</span> <span class=o>=</span> <span class=n>collections</span><span class=o>.</span><span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>pathlib</span><span class=o>.</span><span class=n>Path</span><span class=p>(</span><span class=s1>&#39;dag_dependencies.txt&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>read_text</span><span class=p>()</span><span class=o>.</span><span class=n>splitlines</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>src</span><span class=p>,</span> <span class=n>dst</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39; -&gt; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dependencies</span><span class=p>[</span><span class=n>dst</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>src</span><span class=p>)</span>
</span></span></code></pre></div><p>I made a little data structure to hold the DAG logic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>dataclasses</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>graphlib</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@dataclasses.dataclass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DAG</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>dependencies</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>set</span><span class=p>[</span><span class=nb>str</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=n>durations</span><span class=p>:</span> <span class=nb>dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=nb>float</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@property</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>total_duration</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>float</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;Return the total duration of the DAG.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>topo_order</span> <span class=o>=</span> <span class=n>graphlib</span><span class=o>.</span><span class=n>TopologicalSorter</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=p>)</span><span class=o>.</span><span class=n>static_order</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>finish_time</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>topo_order</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>node</span> <span class=ow>not</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span> <span class=ow>or</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=p>[</span><span class=n>node</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=n>finish_time</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>durations</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>max_dependency_time</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>finish_time</span><span class=p>[</span><span class=n>dep</span><span class=p>]</span> <span class=k>for</span> <span class=n>dep</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=p>[</span><span class=n>node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>finish_time</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>durations</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>+</span> <span class=n>max_dependency_time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>finish_time</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>remove_dependency</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>src</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>dst</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>DAG</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;Return same DAG with one dependency removed.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>dependencies</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>node</span><span class=p>:</span> <span class=n>deps</span> <span class=o>-</span> <span class=p>{</span><span class=n>src</span><span class=p>}</span> <span class=k>if</span> <span class=n>node</span> <span class=o>==</span> <span class=n>dst</span> <span class=k>else</span> <span class=n>deps</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>node</span><span class=p>,</span> <span class=n>deps</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=o>.</span><span class=n>items</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>DAG</span><span class=p>(</span><span class=n>dependencies</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>durations</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>set_duration</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>duration</span><span class=p>:</span> <span class=nb>float</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>DAG</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;Return same DAG with duration of one node updated.&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>durations</span> <span class=o>=</span> <span class=p>{</span><span class=o>**</span><span class=bp>self</span><span class=o>.</span><span class=n>durations</span><span class=p>,</span> <span class=n>node</span><span class=p>:</span> <span class=n>duration</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>DAG</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=p>,</span> <span class=n>durations</span><span class=p>)</span>
</span></span></code></pre></div><p>This says the total duration of my DAG is ~9 minutes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>dag</span> <span class=o>=</span> <span class=n>DAG</span><span class=p>(</span><span class=n>dependencies</span><span class=p>,</span> <span class=n>durations</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>dag</span><span class=o>.</span><span class=n>total_duration</span>
</span></span></code></pre></div><pre tabindex=0><code>539
</code></pre><p>This is slightly under the 10 minutes I mentioned earlier. That&rsquo;s because of some non-DAG stuff in the GitHub Action counting towards the 10 minutes, as well as rounding errors. Anyway, it doesn&rsquo;t matter. The point is that I have a number to optimize against.</p><p>Here&rsquo;s a ranking of the top 10 queries by duration:</p><pre tabindex=0><code>#01 00:04:00 #46
#02 00:02:38 #69
#03 00:02:28 #51
#04 00:01:37 #45
#05 00:01:07 #118
#06 00:01:06 #56
#07 00:00:56 #91
#08 00:00:56 #116
#09 00:00:56 #117
#10 00:00:36 #63
</code></pre><p>That top query <code>#46</code> appears as a low hanging fruit to optimize. But it turns out it&rsquo;s not a bottleneck, and there&rsquo;s actually no point optimizing it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>dag</span><span class=o>.</span><span class=n>set_duration</span><span class=p>(</span><span class=s1>&#39;#46&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>total_duration</span>
</span></span></code></pre></div><pre tabindex=0><code>539
</code></pre><p>Why? Because even if it&rsquo;s taking a long time to run, it&rsquo;s doing so in parallel with other queries. The total duration of the DAG is not affected by the duration of this query.</p><p>Likewise, I had a hunch removing the dependency between <code>#83</code> and <code>#84</code> would help, but it doesn&rsquo;t:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=o>&gt;&gt;&gt;</span> <span class=n>dag</span><span class=o>.</span><span class=n>remove_dependency</span><span class=p>(</span><span class=s1>&#39;#83&#39;</span><span class=p>,</span> <span class=s1>&#39;#84&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>total_duration</span>
</span></span></code></pre></div><pre tabindex=0><code>539
</code></pre><p>Reducing the runtime of a DAG isn&rsquo;t that straightforward. Again, because everything is running in parallel, it&rsquo;s not clear how to assess the impact of a change. I thus opted for a brute-force strategy: try out all possible changes, and rank them by impact. I started by considering all the single dependencies that I could remove. I searched for candidate removals as long as they led to an improvement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>current_dag</span> <span class=o>=</span> <span class=n>dag</span>
</span></span><span class=line><span class=cl><span class=n>current_cost</span> <span class=o>=</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>total_cost</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>candidates</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>dep</span><span class=p>):</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>current_dag</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=n>remove_dependency</span><span class=p>(</span><span class=n>src</span><span class=o>=</span><span class=n>dep</span><span class=p>,</span> <span class=n>dst</span><span class=o>=</span><span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=n>total_cost</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>node</span><span class=p>,</span> <span class=n>dependencies</span> <span class=ow>in</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>dependencies</span><span class=o>.</span><span class=n>items</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>dep</span> <span class=ow>in</span> <span class=n>dependencies</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>best_candidate</span><span class=p>,</span> <span class=n>best_candidate_cost</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>candidates</span><span class=o>.</span><span class=n>items</span><span class=p>(),</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>best_candidate_cost</span> <span class=o>&gt;=</span> <span class=n>current_cost</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=n>current_cost</span> <span class=o>=</span> <span class=n>best_candidate_cost</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Cut </span><span class=si>{</span><span class=n>current_dag</span><span class=o>.</span><span class=n>total_cost</span> <span class=o>-</span> <span class=n>current_cost</span><span class=si>:</span><span class=s1>.0f</span><span class=si>}</span><span class=s1> seconds by removing </span><span class=si>{</span><span class=n>best_candidate</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=si>}</span><span class=s1> -&gt; </span><span class=si>{</span><span class=n>best_candidate</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>current_dag</span> <span class=o>=</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>remove_dependency</span><span class=p>(</span><span class=n>src</span><span class=o>=</span><span class=n>best_candidate</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>dst</span><span class=o>=</span><span class=n>best_candidate</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>dag</span><span class=o>.</span><span class=n>total_cost</span> <span class=o>-</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>total_cost</span><span class=si>:</span><span class=s1>.0f</span><span class=si>}</span><span class=s1> seconds can be cut in total&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;That&#39;s a potential </span><span class=si>{</span><span class=p>(</span><span class=n>dag</span><span class=o>.</span><span class=n>total_cost</span> <span class=o>-</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>total_cost</span><span class=p>)</span> <span class=o>/</span> <span class=n>dag</span><span class=o>.</span><span class=n>total_cost</span><span class=si>:</span><span class=s2>.0%</span><span class=si>}</span><span class=s2> improvement&#34;</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>Cut 45 seconds by removing #117 -&gt; #116
Cut 26 seconds by removing #52 -&gt; #53
Cut 22 seconds by removing #54 -&gt; #49
Cut 11 seconds by removing #114 -&gt; #69
Cut 11 seconds by removing #45 -&gt; #69
Cut 11 seconds by removing #150 -&gt; #118
Cut 4 seconds by removing #116 -&gt; #140
Cut 6 seconds by removing #118 -&gt; #140
Cut 4 seconds by removing #116 -&gt; #69
140 seconds can be cut in total
That&#39;s a potential 26% improvement
</code></pre><p>Not bad. I also tried reducing each query&rsquo;s duration by 50%. Same, I kept searching for candidates as long as there were improvements:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>current_dag</span> <span class=o>=</span> <span class=n>dag</span>
</span></span><span class=line><span class=cl><span class=n>current_duration</span> <span class=o>=</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>total_duration</span>
</span></span><span class=line><span class=cl><span class=n>already_optimized</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>candidates</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>node</span><span class=p>:</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>current_dag</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=n>set_duration</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>durations</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>//</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=o>.</span><span class=n>total_duration</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>node</span> <span class=ow>in</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>dependencies</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>node</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>already_optimized</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>best_candidate</span><span class=p>,</span> <span class=n>best_candidate_duration</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>candidates</span><span class=o>.</span><span class=n>items</span><span class=p>(),</span> <span class=n>key</span><span class=o>=</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>best_candidate_duration</span> <span class=o>&gt;=</span> <span class=n>current_duration</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=n>current_duration</span> <span class=o>=</span> <span class=n>best_candidate_duration</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Cut </span><span class=si>{</span><span class=n>current_dag</span><span class=o>.</span><span class=n>total_duration</span> <span class=o>-</span> <span class=n>current_duration</span><span class=si>:</span><span class=s1>.0f</span><span class=si>}</span><span class=s1> seconds by optimizing </span><span class=si>{</span><span class=n>best_candidate</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>current_dag</span> <span class=o>=</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>set_duration</span><span class=p>(</span><span class=n>best_candidate</span><span class=p>,</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>durations</span><span class=p>[</span><span class=n>best_candidate</span><span class=p>]</span> <span class=o>//</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>already_optimized</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>best_candidate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>dag</span><span class=o>.</span><span class=n>total_duration</span> <span class=o>-</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>total_duration</span><span class=si>:</span><span class=s1>.0f</span><span class=si>}</span><span class=s1> seconds can be cut in total&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;That&#39;s a potential </span><span class=si>{</span><span class=p>(</span><span class=n>dag</span><span class=o>.</span><span class=n>total_duration</span> <span class=o>-</span> <span class=n>current_dag</span><span class=o>.</span><span class=n>total_duration</span><span class=p>)</span> <span class=o>/</span> <span class=n>dag</span><span class=o>.</span><span class=n>total_duration</span><span class=si>:</span><span class=s2>.0%</span><span class=si>}</span><span class=s2> improvement&#34;</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>Cut 79 seconds by optimizing #69
Cut 26 seconds by optimizing #56
Cut 20 seconds by optimizing #116
Cut 13 seconds by optimizing #54
Cut 8 seconds by optimizing #53
Cut 8 seconds by optimizing #49
Cut 4 seconds by optimizing #87
158 seconds can be cut in total
That&#39;s a potential 29% improvement
</code></pre><p>Also not bad.</p><p>I&rsquo;m not sure how much of these suggestions I&rsquo;ll implement. But now at least I know where to focus my efforts. I hope this blog post will inspire you to do the same!</p><p><em>Part of the reason I&rsquo;m posting this half-baked solution is to manifest Cunningham&rsquo;s Law. If you have a better solution, please let me know! üôè</em></p></div><script type=text/javascript>var s=document.createElement("script");s.setAttribute("src","https://utteranc.es/client.js"),s.setAttribute("repo","MaxHalford/maxhalford.github.io"),s.setAttribute("issue-term","pathname"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",null),s.setAttribute("theme","github-light"),document.body.appendChild(s)</script><div style=display:flex;flex-direction:row;justify-content:center;align-items:center;gap:20px;margin-bottom:30px><div class=do-the-thing><div class=elevator><svg class="sweet-svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" enable-background="new 0 0 100 100" height="100" width="100"><path d="M70 47.5H30c-1.4.0-2.5 1.1-2.5 2.5v40c0 1.4 1.1 2.5 2.5 2.5h40c1.4.0 2.5-1.1 2.5-2.5V50C72.5 48.6 71.4 47.5 70 47.5zm-22.5 40h-5v-25h5v25zm10 0h-5v-25h5v25zm10 0h-5V60c0-1.4-1.1-2.5-2.5-2.5H40c-1.4.0-2.5 1.1-2.5 2.5v27.5h-5v-35h35v35z"/><path d="M50 42.5c1.4.0 2.5-1.1 2.5-2.5V16l5.7 5.7c.5.5 1.1.7 1.8.7s1.3-.2 1.8-.7c1-1 1-2.6.0-3.5l-10-10c-1-1-2.6-1-3.5.0l-10 10c-1 1-1 2.6.0 3.5 1 1 2.6 1 3.5.0l5.7-5.7v24c0 1.4 1.1 2.5 2.5 2.5z"/></svg>
Back to the top</div></div><div class=subscribe><a href=http://eepurl.com/iRBqMg>Subscribe</a></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/elevator.js/1.0.1/elevator.min.js></script><script>var elementButton=document.querySelector(".elevator"),elevator=new Elevator({element:elementButton,mainAudio:"/music/elevator.mp3",endAudio:"/music/ding.mp3"})</script><style>.down-arrow{font-size:120px;margin-top:90px;margin-bottom:90px;text-shadow:0 -20px #0c1f31,0 0 #c33329;color:transparent;-webkit-transform:scaleY(.8);-moz-transform:scaleY(.8);transform:scaleY(.8)}.elevator{text-align:center;cursor:pointer;width:140px;margin:auto}.elevator:hover{opacity:.7}.elevator svg{width:40px;height:40px;display:block;margin:auto;margin-bottom:5px}</style><div class=related-content><h3 style="margin-top:10px !important;margin-bottom:10px !important">Related posts</h3><ul style=margin-top:0><li><a href=/blog/weighted-sampling-without-replacement/>Weighted sampling without replacement in pure Python</a></li><li><a href=/blog/python-daily-cache/>@daily_cache implementation in Python</a></li><li><a href="https://www.youtube.com/watch?v=kiWW4Oty8kY">Introducing icanexplain @ PyData Paris 2024</a></li></ul></div></div></div></article></body></html>